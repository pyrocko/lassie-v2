{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Qseek \ud83d\udd25","text":"<p>Qseek is an earthquake detection and localisation framework. It combines modern machine learning phase detection and robust migration and stacking techniques.</p> <p>The detector is leveraging Pyrocko and SeisBench, it is highly-performant and can search massive data sets for seismic activity efficiently.</p> <p>Citation</p> <p>Marius Paul Isken, Peter Niemz, Jannes M\u00fcnchmeyer, Sebastian Heimann, Simone Cesca, Torsten Dahm, Qseek: A data-driven Framework for Machine-Learning Earthquake Detection, Localization and Characterization, Seismica, 2024, submitted</p> <p></p> <p>Seismic swarm activity at Iceland, Reykjanes Peninsula during a 2020 unrest. 15,000+ earthquakes detected, outlining a dike intrusion, preceeding the 2021 Fagradasfjall eruption. Visualized in Pyrocko Sparrow.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> Earthquake phase detection using machine-learning pickers from SeisBench<ul> <li> PhaseNet (Zhu and Beroza, 2018</li> <li> EQTransformer (Mousavi et al., 2020)</li> <li> OBSTransformer (Niksejel and Zahng, 2024)</li> <li> LFEDetect</li> </ul> </li> <li> Octree localisation approach for efficient and accurate search</li> <li> Different velocity models:<ul> <li> Constant velocity</li> <li> 1D Layered velocity model</li> <li> 3D fast-marching velocity model (NonLinLoc compatible)</li> </ul> </li> <li> Extraction of earthquake event features:<ul> <li> Local magnitudes</li> <li> Ground motion attributes</li> </ul> </li> <li> Automatic extraction of modelled and picked travel times</li> <li> Calculation and application of station corrections / station delay times</li> <li> Real-time analytics on streaming data (e.g. SeedLink)</li> </ul> <p>Get Started!</p>"},{"location":"#build-with","title":"Build with","text":""},{"location":"benchmark/","title":"Benchmark","text":""},{"location":"benchmark/#computation-performance","title":"Computation Performance","text":"<p>Qseek is built for searching in large-N data sets. The implementation is leveraging Python <code>asyncio</code> heavily to implement threading and keeping the CPU busy. It is built on top of highly performant Pyrocko functions implemented in C language. The inference is using PyTorch which enables GPU computation of the seismic imaging functions.</p> <p>This enables high throughput of seismic data in different scenarios.</p> Number Stations Throughput in MB Throughput in Waveform data 300+ 50 MB/sec 12 hours/sec 50 200 MB/sec 6 hours/sec <p>Scanning a 600 GB (~700 years of waveforms) data set costs ~2 days on a 64 cores machine equipped with an Nvidia A100 GPU.</p> <p>Note</p> <p>The performance depends heavily on the octree resolution and the number of events detected in the data set.</p>"},{"location":"benchmark/#related-projects","title":"Related Projects","text":"<p>A list of other projects using stacking and migration approach to back-project seismic energy sources in 3D space:</p>"},{"location":"benchmark/#lassie-v1","title":"Lassie-v1","text":"<p>Lassie - The friendly Earthquake detector in version 1. Qseek utilizes the same optimized heavy-duty functions for stacking and migration as Lassie v1.</p> <p>Lassie-v1 on Pyrocko Git</p>"},{"location":"benchmark/#quakemigrate","title":"QuakeMigrate","text":"<p>QuakeMigrate uses a waveform migration and stacking algorithm to search for coherent seismic phase arrivals across a network of instruments. It produces\u2014from raw data\u2014catalogues of earthquakes with locations, origin times, phase arrival picks, and local magnitude estimates, as well as rigorous estimates of the associated uncertainties.</p> <p>QuakeMigrate on GitHub</p>"},{"location":"benchmark/#bpmf","title":"BPMF","text":"<p>Complete framework for earthquake detection and location: Backprojection and matched-filtering (BPMF), with methods for automatic picking, relocation and efficient waveform stacking.</p> <p>BPMF on GitHub</p>"},{"location":"benchmark/#loki","title":"Loki","text":"<p>LOKI (LOcation of seismic events through traveltime staKIng) is a code that performs earthquake detection and location using waveform coherence analysis (waveform stacking).</p> <p>Loki on GitHub</p>"},{"location":"benchmark/#malmi","title":"MALMI","text":"<p>MALMI (MAchine Learning aided earthquake MIgration location), variant of Loki for detecting and locating earthquakes using ML image functions provided by SeisBench.</p> <p>MALMI on GitHub</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>The installation is straight-forward using pip or pipx.</p> From GitHub<pre><code>pip install git+https://github.com/pyrocko/qseek\n</code></pre> <p>or</p> Using pipx<pre><code>pipx install git+https://github.com/pyrocko/qseek\n</code></pre>"},{"location":"getting_started/#running-qseek","title":"Running Qseek","text":"<p>The main entry point in the executeable is the <code>qseek</code> command. The provided command line interface (CLI) and a JSON config file is all what is needed to run the program.</p> <pre><code>qseek --help\n</code></pre> <pre><code>usage: qseek [-h] [--verbose] [--version]\n             {config,search,continue,snuffler,feature-extraction,modules,serve,export,clear-cache,dump-schemas}\n             ...\n\nqseek - The wholesome earthquake detector \ud83d\ude80\n\noptions:\n  -h, --help            show this help message and exit\n  --verbose, -v         increase verbosity of the log messages, repeat to\n                        increase. Default level is INFO\n  --version             show version and exit\n\ncommands:\n  Available commands to run qseek. Get command help with `qseek &lt;command&gt;\n  --help`.\n\n  {config,search,continue,snuffler,feature-extraction,modules,serve,export,clear-cache,dump-schemas}\n    config              print a new config\n    search              start a search\n    continue            continue an existing search\n    snuffler            start the Pyrocko snuffler to inspect waveforms,\n                        events and picks\n    feature-extraction  extract features from an existing run\n    modules             show available modules\n    serve               start webserver and serve results from an existing run\n    export              export detections to different output formats\n    clear-cache         clear the cach directory\n    dump-schemas        dump data models to json-schema (development)\n</code></pre>"},{"location":"getting_started/#initializing-a-new-project","title":"Initializing a New Project","text":"<p>Once installed you can run the <code>qseek</code> executeable to initialize a new project.</p> Initialize new Project<pre><code>qseek config &gt; my-search.json\n</code></pre> <p>Check out the <code>my-search.json</code> config file and add your waveform data and velocity models.</p> Minimal Configuration Example <p>Here is a minimal JSON configuration for Qseek. <pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"pyrocko_station_yamls\": [],\n    \"station_xmls\": [],\n    \"blacklist\": [],\n    \"stations\": [],\n    \"max_distance\": null\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"environment\": null,\n    \"persistent\": null,\n    \"waveform_dirs\": [\n      \"./data\"\n    ],\n    \"start_time\": null,\n    \"end_time\": null,\n    \"channel_selector\": null,\n    \"n_threads\": 8,\n    \"watch_waveforms\": false\n  },\n  \"pre_processing\": [\n    {\n      \"process\": \"downsample\",\n      \"stations\": [],\n      \"sampling_frequency\": 100.0\n    },\n    {\n      \"process\": \"bandpass\",\n      \"stations\": [],\n      \"corners\": 4,\n      \"bandpass\": [\n        0.5,\n        30.0\n      ],\n      \"demean\": true\n    }\n  ],\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 1000.0,\n    \"n_levels\": 5,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ]\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"SeisBench\",\n      \"model\": \"PhaseNet\",\n      \"pretrained\": \"original\",\n      \"window_overlap_samples\": 1500,\n      \"torch_use_cuda\": true,\n      \"torch_cpu_threads\": 4,\n      \"batch_size\": 128,\n      \"stack_method\": \"avg\",\n      \"rescale_input\": 1.0,\n      \"phase_map\": {\n        \"P\": \"cake:P\",\n        \"S\": \"cake:S\"\n      },\n      \"weights\": {\n        \"P\": 1.0,\n        \"S\": 1.0\n      }\n    }\n  ],\n  \"ray_tracers\": [\n    {\n      \"tracer\": \"CakeTracer\",\n      \"phases\": {\n        \"cake:P\": {\n          \"definition\": \"P,p\"\n        },\n        \"cake:S\": {\n          \"definition\": \"S,s\"\n        }\n      },\n      \"earthmodel\": {\n        \"filename\": \"/home/runner/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": \"\\n-1.00    5.50    3.59    2.7\\n 0.00    5.50    3.59    2.7\\n 1.00    5.50    3.59    2.7\\n 1.00    6.00    3.92    2.7\\n 4.00    6.00    3.92    2.7\\n 4.00    6.20    4.05    2.7\\n 8.00    6.20    4.05    2.7\\n 8.00    6.30    4.12    2.7\\n13.00    6.30    4.12    2.7\\n13.00    6.40    4.18    2.7\\n17.00    6.40    4.18    2.7\\n17.00    6.50    4.25    2.7\\n22.00    6.50    4.25    2.7\\n22.00    6.60    4.31    2.7\\n26.00    6.60    4.31    2.7\\n26.00    6.80    4.44    2.7\\n30.00    6.80    4.44    2.7\\n30.00    8.10    5.29    2.7\\n45.00    8.10    5.29    2.7\\n\"\n      },\n      \"trim_earth_model_depth\": true,\n      \"lut_cache_size\": 2147483648\n    },\n    {\n      \"tracer\": \"ConstantVelocityTracer\",\n      \"phase\": \"constant:P\",\n      \"velocity\": 5000.0\n    }\n  ],\n  \"distance_weights\": {\n    \"exponent\": 3.0,\n    \"radius_meters\": \"mean_interstation\",\n    \"waterlevel\": 0.0,\n    \"lut_cache_size\": 209715200\n  },\n  \"station_corrections\": null,\n  \"magnitudes\": [],\n  \"features\": [],\n  \"semblance_sampling_rate\": 100,\n  \"detection_threshold\": 0.2,\n  \"pick_confidence_threshold\": 0.2,\n  \"min_stations\": 3,\n  \"absorbing_boundary\": false,\n  \"absorbing_boundary_width\": \"root_node_size\",\n  \"node_peak_interpolation\": true,\n  \"detection_blinding\": \"PT1S\",\n  \"power_mean\": 1.0,\n  \"window_length\": \"PT5M\",\n  \"n_threads_parstack\": \"auto\",\n  \"n_threads_argmax\": \"auto\",\n  \"plot_octree_surface\": false,\n  \"created\": \"2024-12-04T16:53:08.711418Z\"\n}\n</code></pre></p> <p>For more details and information about the component, head over to details of the modules.</p>"},{"location":"getting_started/#starting-the-search","title":"Starting the Search","text":"<p>Once happy with the configuration, start the <code>qseek</code> CLI.</p> Start the earthquake detection and localization<pre><code>qseek search my-search.json\n</code></pre>"},{"location":"visualizing_results/","title":"Visualizing Detections","text":"<p>The event detections are exported in Qseek-native JSON, Pyrocko YAML format and as CSV files.</p>"},{"location":"visualizing_results/#pyrocko-sparrow","title":"Pyrocko Sparrow","text":"<p>For large data sets use the Pyrocko Sparrow to visualise seismic event detections in 3D. Also seismic stations and many other features from the Pyrocko ecosystem can be integrated into the view.</p> <p></p>"},{"location":"visualizing_results/#qgis","title":"QGIS","text":"<p>QGIS can be used to import <code>.csv</code> and explore the data in an interactive fashion. Detections can be rendered by e.g. the detection semblance or the calculated magnitude.</p> <p></p>"},{"location":"components/configuration/","title":"Qseek Configuration","text":"<p>At center is a JSON configuration file which is parsed by Pydantic. The following pages will detail how to setup this JSON file for the search.</p> <p>See the getting started guide for a brief introduction into the CLI.</p> <p>General configuration conventions are outlines in this guide as well.</p> <p>Create a new config file.</p> Using the CLI<pre><code>qseek config\n</code></pre>"},{"location":"components/configuration/#the-search","title":"The Search","text":"<p>The search configuration. This is the entrypoint for the EQ detection and localisation. More information on the submodules (e.g. Octree, Data Provider and other) can be found on subpages in the navigation.</p> <p></p>"},{"location":"components/configuration/#exec-3--search-module","title":"Search Module","text":"Config SearchJSON  <code>stations</code> <p>Station inventory from StationXML or Pyrocko Station YAML.</p> <code>data_provider</code> <p>Data provider for waveform data.</p> <code>pre_processing</code> <p>Pre-processing steps for waveform data.</p> <code>octree</code> <p>Octree volume for the search.</p> <code>image_functions</code> <p>Image functions for waveform processing and phase on-set detection.</p> <code>ray_tracers</code> <p>List of ray tracers for travel time calculation.</p> <code>distance_weights</code> <p>Spatial weights for distance weighting.</p> <code>station_corrections</code> <p>Apply station corrections extracted from a previous run.</p> <code>magnitudes</code> <p>Magnitude calculators to use.</p> <code>features</code> <p>Event features to extract.</p> <code>semblance_sampling_rate</code>: <code>10 | 20 | 25 | 50 | 100 | 200 | 400</code> <p>Sampling rate for the semblance image function. Choose from <code>10, 20, 25, 50, 100, 200 or 400</code> Hz.</p> <code>detection_threshold</code>: <code>0.2</code> <p>Detection threshold for semblance.</p> <code>pick_confidence_threshold</code>: <code>0.2</code> <p>Confidence threshold for picking.</p> <code>min_stations</code>: <code>3</code> <p>Minimum number of stations required for detection and localization.</p> <code>absorbing_boundary</code>: <code>False | with_surface | without_surface</code> <p>Ignore events that are inside the first root node layer of the octree. If <code>with_surface</code>, all events inside the boundaries of the volume are absorbed. If <code>without_surface</code>, events at the surface are not absorbed.</p> <code>absorbing_boundary_width</code> <p>Width of the absorbing boundary around the octree volume. If 'octree' the width is set to the root node size of the octree.</p> <code>node_peak_interpolation</code>: <code>True</code> <p>Interpolate intranode locations for detected events using radial basis functions. If <code>False</code>, the node center location is used for the event hypocentre.</p> <code>detection_blinding</code> <p>Blinding time in seconds before and after the detection peak. This is used to avoid detecting the same event multiple times. Default is 2 seconds.</p> <code>power_mean</code>: <code>1.0</code> <p>Power mean exponent for stacking and combining the image functions for stacking. A value of 1.0 is the arithmetic mean, 2.0 is the quadratic mean. A higher value will result in sharper detections and low values smooth the stacking function.</p> <code>window_length</code> <p>Window length for processing. Smaller window size will be less RAM consuming. Default is 5 minutes.</p> <code>n_threads_parstack</code> <p>Number of threads for stacking and migration. <code>'auto'</code> will use the maximum number of cores and leaves resources for I/O and other work. <code>0</code> uses all available cores.</p> <code>n_threads_argmax</code> <p>Number of threads for argmax. <code>'auto'</code> will use the maximum number of cores and leaves resources for I/O and other work. <code>0</code> uses all available cores.</p> JSON for Search<pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"pyrocko_station_yamls\": [],\n    \"station_xmls\": [],\n    \"blacklist\": [],\n    \"stations\": [],\n    \"max_distance\": null\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"environment\": null,\n    \"persistent\": null,\n    \"waveform_dirs\": [\n      \"./data\"\n    ],\n    \"start_time\": null,\n    \"end_time\": null,\n    \"channel_selector\": null,\n    \"n_threads\": 8,\n    \"watch_waveforms\": false\n  },\n  \"pre_processing\": [\n    {\n      \"process\": \"downsample\",\n      \"stations\": [],\n      \"sampling_frequency\": 100.0\n    },\n    {\n      \"process\": \"bandpass\",\n      \"stations\": [],\n      \"corners\": 4,\n      \"bandpass\": [\n        0.5,\n        30.0\n      ],\n      \"demean\": true\n    }\n  ],\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 1000.0,\n    \"n_levels\": 5,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ]\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"SeisBench\",\n      \"model\": \"PhaseNet\",\n      \"pretrained\": \"original\",\n      \"window_overlap_samples\": 1500,\n      \"torch_use_cuda\": true,\n      \"torch_cpu_threads\": 4,\n      \"batch_size\": 128,\n      \"stack_method\": \"avg\",\n      \"rescale_input\": 1.0,\n      \"phase_map\": {\n        \"P\": \"cake:P\",\n        \"S\": \"cake:S\"\n      },\n      \"weights\": {\n        \"P\": 1.0,\n        \"S\": 1.0\n      }\n    }\n  ],\n  \"ray_tracers\": [\n    {\n      \"tracer\": \"CakeTracer\",\n      \"phases\": {\n        \"cake:P\": {\n          \"definition\": \"P,p\"\n        },\n        \"cake:S\": {\n          \"definition\": \"S,s\"\n        }\n      },\n      \"earthmodel\": {\n        \"filename\": \"/home/runner/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": \"\\n-1.00    5.50    3.59    2.7\\n 0.00    5.50    3.59    2.7\\n 1.00    5.50    3.59    2.7\\n 1.00    6.00    3.92    2.7\\n 4.00    6.00    3.92    2.7\\n 4.00    6.20    4.05    2.7\\n 8.00    6.20    4.05    2.7\\n 8.00    6.30    4.12    2.7\\n13.00    6.30    4.12    2.7\\n13.00    6.40    4.18    2.7\\n17.00    6.40    4.18    2.7\\n17.00    6.50    4.25    2.7\\n22.00    6.50    4.25    2.7\\n22.00    6.60    4.31    2.7\\n26.00    6.60    4.31    2.7\\n26.00    6.80    4.44    2.7\\n30.00    6.80    4.44    2.7\\n30.00    8.10    5.29    2.7\\n45.00    8.10    5.29    2.7\\n\"\n      },\n      \"trim_earth_model_depth\": true,\n      \"lut_cache_size\": 2147483648\n    },\n    {\n      \"tracer\": \"ConstantVelocityTracer\",\n      \"phase\": \"constant:P\",\n      \"velocity\": 5000.0\n    }\n  ],\n  \"distance_weights\": {\n    \"exponent\": 3.0,\n    \"radius_meters\": \"mean_interstation\",\n    \"waterlevel\": 0.0,\n    \"lut_cache_size\": 209715200\n  },\n  \"station_corrections\": null,\n  \"magnitudes\": [],\n  \"features\": [],\n  \"semblance_sampling_rate\": 100,\n  \"detection_threshold\": 0.2,\n  \"pick_confidence_threshold\": 0.2,\n  \"min_stations\": 3,\n  \"absorbing_boundary\": false,\n  \"absorbing_boundary_width\": \"root_node_size\",\n  \"node_peak_interpolation\": true,\n  \"detection_blinding\": \"PT1S\",\n  \"power_mean\": 1.0,\n  \"window_length\": \"PT5M\",\n  \"n_threads_parstack\": \"auto\",\n  \"n_threads_argmax\": \"auto\",\n  \"plot_octree_surface\": false,\n  \"created\": \"2024-12-04T16:53:10.318664Z\"\n}\n</code></pre>"},{"location":"components/configuration/#minimal-config","title":"Minimal Config","text":"<p>This is a minimal config which can used to start a Qseek search.</p> Minimal Qseek Config<pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"station_xmls\": [],\n    \"pyrocko_station_yamls\": [\"search/pyrocko-stations.yaml\"],\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"environment\": \".\",\n    \"waveform_dirs\": [\"data/\"],\n  },\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 2000.0,\n    \"n_levels\": 3,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ],\n    \"absorbing_boundary\": 1000.0\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"PhaseNet\",\n      \"model\": \"ethz\",\n      \"torch_use_cuda\": false,\n      \"phase_map\": {\n        \"P\": \"constant:P\",\n        \"S\": \"constant:S\"\n      },\n    }\n  ],\n  \"ray_tracers\": [\n    {\n    \"tracer\": \"ConstantVelocityTracer\",\n    \"phase\": \"constant:P\",\n    \"velocity\": 5000.0\n    }\n  ],\n  \"station_corrections\": {},\n  \"event_features\": [],\n  \"sampling_rate\": 100,\n  \"detection_threshold\": 0.05,\n  \"detection_blinding\": \"PT2S\",\n  \"node_split_threshold\": 0.9,\n  \"window_length\": \"PT300S\",\n  \"n_threads_parstack\": 0,\n  \"n_threads_argmax\": 4,\n}\n</code></pre>"},{"location":"components/configuration/#structure","title":"Structure","text":"<p>Structure of the search and optimisation of the octree, which is focusing in on seismic energy.</p> <pre><code>%%{init: {'theme': 'neutral', 'themeVariables': { 'fontSize': '14pt'}}}%%\nflowchart LR\n    subgraph Seismic Data\n        waveforms([\"fa:fa-water Seismic\\nWaveforms\"])\n        image{{\"fa:fa-bolt Waveform Image Function\\nPhaseNet / EQTransformer / ...\"}}\n        waveforms --&gt; image\n    end\n    subgraph Travel Time Model\n        travelTimes([\"fa:fa-layer-group Seismic\\nTravel Time Model\"])\n        stationCorrections{{\"fab:fa-arrows-to-dot Station Corrections\\nSST / SSST\"}}\n        travelTimes --&gt;|add| stationCorrections\n    end\n    subgraph Stacking and Migration\n        octree[\"fa:fa-cubes\\nOctree Grid\"]\n        detection[\"fa:fa-bullseye Detection\\nand Localisation\"]\n    end\n    featureExtraction(\"fa:fa-info Extract Event Features\\nMagnitudes, Ground Motion, ...\")\n    correctionExtraction(\"fa:fa-stopwatch Extract\\nStation Corrections\")\n\n    image --&gt; octree\n    stationCorrections --&gt; octree\n    detection -.-&gt;|\"fa:fa-cube\\nRefine\"| octree\n    octree --&gt; detection\n    detection --&gt; featureExtraction &amp; correctionExtraction\n</code></pre> <p>Building blocks of the specific stacking and migration method for earthquake detection, localisation and characterisation.</p>"},{"location":"components/general/","title":"General Settings","text":""},{"location":"components/general/#paths","title":"Paths","text":"<p>Paths can be relative to the location of the config file or absolute. File paths and directory paths are checked whether they exist.</p>"},{"location":"components/general/#date-and-time","title":"Date and Time","text":"<p>Serialisation of time, dates and date times and durations follow ISO8601 format with timezone information. E.g. <code>2023-10-28T01:21:21.003Z</code>.</p> <p>Duration are serialized like <code>PT600S</code>, this example shows a duration of 600 seconds, 10 minutes.</p> <p>!!!+ note Timezone Info     All datetimes are timezone aware! For UTC this is the <code>Z</code> or <code>+00:00</code> suffix.     Also other offsets can be defined according to ISO8601.</p> Example of datetimes and durations<pre><code>{\n    \"start_time\": \"2023-10-28T01:21:21.003+00:00\",\n    \"end_time\": \"2023-10-28T01:21:21.003+00:00\",\n    \"duration\": \"PT600S\"\n}\n</code></pre>"},{"location":"components/general/#locations","title":"Locations","text":"<p>Geographic locations have a geographic reference and a relative shift in meters. The octree or velocity models are referenced using Location objects.</p> <p>All distances, depths and elevations are given in meters.</p> <p></p>"},{"location":"components/general/#exec-4--location-module","title":"Location Module","text":"Config LocationJSON  <code>lat</code>: <code>PydanticUndefined</code> <p>Latitude in degrees.</p> <code>lon</code>: <code>PydanticUndefined</code> <p>Longitude in degrees.</p> <code>east_shift</code>: <code>0.0</code> <p>East shift towards geographical reference in meters.</p> <code>north_shift</code>: <code>0.0</code> <p>North shift towards geographical reference in meters.</p> <code>elevation</code>: <code>0.0</code> <p>Elevation in meters.</p> <code>depth</code>: <code>0.0</code> <p>Depth in meters, positive is down.</p> JSON for Location<pre><code>{\n  \"lat\": 52.3825,\n  \"lon\": 13.0644,\n  \"east_shift\": 0.0,\n  \"north_shift\": 0.0,\n  \"elevation\": 0.0,\n  \"depth\": 0.0\n}\n</code></pre>"},{"location":"components/image_function/","title":"Image Function","text":"<p>For image functions this version of Qseek relies heavily on machine learning pickers delivered by SeisBench.</p>"},{"location":"components/image_function/#seisbench-image-function","title":"SeisBench Image Function","text":"<p>SeisBench offers access to a variety of machine learning phase pickers pre-trained on various data sets.</p> <p>Citation PhaseNet</p> <p>Zhu, Weiqiang, and Gregory C. Beroza. \"PhaseNet: A Deep-Neural-Network-Based Seismic Arrival Time Picking Method.\" arXiv preprint arXiv:1803.03211 (2018).</p> <p></p>"},{"location":"components/image_function/#exec-5--seisbench-module","title":"SeisBench Module","text":"<p>PhaseNet image function. For more details see SeisBench documentation.</p> Config SeisBenchJSON  <code>model</code>: <code>PhaseNet | EQTransformer | OBSTransformer | LFEDetect</code> <p>The model to use for the image function. Currently supported models are <code>PhaseNet</code>, <code>EQTransformer</code>, <code>GPD</code>, <code>OBSTransformer</code>, <code>LFEDetect</code>.</p> <code>pretrained</code>: <code>cascadia | cms | diting | dummy | ethz | geofon | instance | iquique | jcms | jcs | jms | lendb | mexico | nankai | neic | obs | obst2024 | original | original_nonconservative | san_andreas | scedc | stead | volpick</code> <p>SeisBench pre-trained model to use. Choose from <code>ethz</code>, <code>geofon</code>, <code>instance</code>, <code>iquique</code>, <code>lendb</code>, <code>neic</code>, <code>obs</code>, <code>original</code>, <code>scedc</code>, <code>stead</code>. For more details see SeisBench documentation</p> <code>window_overlap_samples</code>: <code>1500</code> <p>Window overlap in samples.</p> <code>torch_use_cuda</code> <p>Use CUDA for inference. If <code>True</code> use default device, if <code>int</code> use the specified device.</p> <code>torch_cpu_threads</code>: <code>4</code> <p>Number of CPU threads to use if only CPU is used.</p> <code>batch_size</code>: <code>128</code> <p>Batch size for inference, larger values can improve performance.</p> <code>stack_method</code>: <code>avg | max</code> <p>Method to stack the overlaping blocks internally. Choose from <code>avg</code> and <code>max</code>.</p> <code>rescale_input</code>: <code>1.0</code> <p>Upscale input by factor. This augments the input data from e.g. 100 Hz to 50 Hz (factor: <code>2</code>). Can be useful for high-frequency microseismic events.</p> <code>phase_map</code> <p>Phase mapping from SeisBench PhaseNet to Lassie phases.</p> <code>weights</code> <p>Weights for each phase.</p> JSON for SeisBench<pre><code>{\n  \"image\": \"SeisBench\",\n  \"model\": \"PhaseNet\",\n  \"pretrained\": \"original\",\n  \"window_overlap_samples\": 1500,\n  \"torch_use_cuda\": true,\n  \"torch_cpu_threads\": 4,\n  \"batch_size\": 128,\n  \"stack_method\": \"avg\",\n  \"rescale_input\": 1.0,\n  \"phase_map\": {\n    \"P\": \"cake:P\",\n    \"S\": \"cake:S\"\n  },\n  \"weights\": {\n    \"P\": 1.0,\n    \"S\": 1.0\n  }\n}\n</code></pre>"},{"location":"components/octree/","title":"Octree","text":"<p>A 3D space is searched for sources of seismic energy. Qseek created an octree structure which is iteratively refined when energy is detected, to focus on the source' location. This speeds up the search and improves the resolution of the localisations.</p> <p></p> <p>Surface projection of the refined octree focusing on the seismic source region. In this example four levels of refinement are can be seen, refining the 3D octree from the initial 4000 nodes to 8823 nodes.</p> <p></p>"},{"location":"components/octree/#exec-6--octree-module","title":"Octree Module","text":"Config OctreeJSON  <code>location</code> <p>The geographical center of the octree.</p> <code>root_node_size</code>: <code>1000.0</code> <p>Size of the root node at the initial level (level 0) in meters.</p> <code>n_levels</code>: <code>5</code> <p>Number of levels in the octree, defining the final resolution of the detection. Default is 5.</p> <code>east_bounds</code> <p>East bounds of the octree in meters.</p> <code>north_bounds</code> <p>North bounds of the octree in meters.</p> <code>depth_bounds</code> <p>Depth bounds of the octree in meters.</p> JSON for Octree<pre><code>{\n  \"location\": {\n    \"lat\": 0.0,\n    \"lon\": 0.0,\n    \"east_shift\": 0.0,\n    \"north_shift\": 0.0,\n    \"elevation\": 0.0,\n    \"depth\": 0.0\n  },\n  \"root_node_size\": 1000.0,\n  \"n_levels\": 5,\n  \"east_bounds\": [\n    -10000.0,\n    10000.0\n  ],\n  \"north_bounds\": [\n    -10000.0,\n    10000.0\n  ],\n  \"depth_bounds\": [\n    0.0,\n    20000.0\n  ]\n}\n</code></pre>"},{"location":"components/octree/#qseek.octree.Octree","title":"qseek.octree.Octree  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Iterator[Node]</code></p> <p>Config:</p> <ul> <li><code>ignored_types</code>: <code>(cached_property)</code></li> </ul> <p>Fields:</p> <ul> <li> <code>location</code>                 (<code>Location</code>)             </li> <li> <code>root_node_size</code>                 (<code>PositiveFloat</code>)             </li> <li> <code>n_levels</code>                 (<code>int</code>)             </li> <li> <code>east_bounds</code>                 (<code>Range</code>)             </li> <li> <code>north_bounds</code>                 (<code>Range</code>)             </li> <li> <code>depth_bounds</code>                 (<code>Range</code>)             </li> <li> <code>_root_nodes</code>                 (<code>list[Node]</code>)             </li> <li> <code>_semblance</code>                 (<code>ndarray | None</code>)             </li> <li> <code>_cached_coordinates</code>                 (<code>dict[CoordSystem, ndarray]</code>)             </li> <li> <code>_nodes</code>                 (<code>list[Node]</code>)             </li> <li> <code>n_nodes</code>                 (<code>int</code>)             </li> <li> <code>n_leaf_nodes</code>                 (<code>int</code>)             </li> <li> <code>nodes</code>                 (<code>list[Node]</code>)             </li> <li> <code>volume</code>                 (<code>float</code>)             </li> <li> <code>leaf_nodes</code>                 (<code>list[Node]</code>)             </li> <li> <code>semblance</code>                 (<code>ndarray</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>check_reference</code>                 \u2192                   <code>location</code> </li> <li> <code>check_limits</code> </li> </ul>"},{"location":"components/octree/#qseek.octree.Octree.depth_bounds","title":"depth_bounds  <code>pydantic-field</code>","text":"<pre><code>depth_bounds: Range = Range(0 * KM, 20 * KM)\n</code></pre> <p>Depth bounds of the octree in meters.</p>"},{"location":"components/octree/#qseek.octree.Octree.east_bounds","title":"east_bounds  <code>pydantic-field</code>","text":"<pre><code>east_bounds: Range = Range(-10 * KM, 10 * KM)\n</code></pre> <p>East bounds of the octree in meters.</p>"},{"location":"components/octree/#qseek.octree.Octree.leaf_nodes","title":"leaf_nodes  <code>pydantic-field</code>","text":"<pre><code>leaf_nodes: list[Node]\n</code></pre> <p>Get all leaf nodes of the octree.</p> <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: List of leaf nodes.</p>"},{"location":"components/octree/#qseek.octree.Octree.location","title":"location  <code>pydantic-field</code>","text":"<pre><code>location: Location = Location(lat=0.0, lon=0.0)\n</code></pre> <p>The geographical center of the octree.</p>"},{"location":"components/octree/#qseek.octree.Octree.n_leaf_nodes","title":"n_leaf_nodes  <code>pydantic-field</code>","text":"<pre><code>n_leaf_nodes: int\n</code></pre> <p>Number of nodes in the octree.</p>"},{"location":"components/octree/#qseek.octree.Octree.n_levels","title":"n_levels  <code>pydantic-field</code>","text":"<pre><code>n_levels: int = 5\n</code></pre> <p>Number of levels in the octree, defining the final resolution of the detection. Default is 5.</p>"},{"location":"components/octree/#qseek.octree.Octree.n_nodes","title":"n_nodes  <code>pydantic-field</code>","text":"<pre><code>n_nodes: int\n</code></pre> <p>Number of nodes in the octree.</p>"},{"location":"components/octree/#qseek.octree.Octree.nodes","title":"nodes  <code>pydantic-field</code>","text":"<pre><code>nodes: list[Node]\n</code></pre> <p>List of nodes in the octree.</p>"},{"location":"components/octree/#qseek.octree.Octree.north_bounds","title":"north_bounds  <code>pydantic-field</code>","text":"<pre><code>north_bounds: Range = Range(-10 * KM, 10 * KM)\n</code></pre> <p>North bounds of the octree in meters.</p>"},{"location":"components/octree/#qseek.octree.Octree.root_node_size","title":"root_node_size  <code>pydantic-field</code>","text":"<pre><code>root_node_size: PositiveFloat = 1 * KM\n</code></pre> <p>Size of the root node at the initial level (level 0) in meters.</p>"},{"location":"components/octree/#qseek.octree.Octree.semblance","title":"semblance  <code>pydantic-field</code>","text":"<pre><code>semblance: ndarray\n</code></pre> <p>Returns the semblance values of all nodes.</p>"},{"location":"components/octree/#qseek.octree.Octree.volume","title":"volume  <code>pydantic-field</code>","text":"<pre><code>volume: float\n</code></pre> <p>Volume of the octree in cubic meters.</p>"},{"location":"components/octree/#qseek.octree.Octree.cached_bottom","title":"cached_bottom","text":"<pre><code>cached_bottom() -&gt; Self\n</code></pre> <p>Returns a copy of the octree refined to the cached bottom nodes.</p> <p>Raises:</p> Type Description <code>EnvironmentError</code> <p>If the octree has never been split.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Copy of the octree with cached bottom nodes.</p>"},{"location":"components/octree/#qseek.octree.Octree.check_limits","title":"check_limits  <code>pydantic-validator</code>","text":"<pre><code>check_limits() -&gt; Octree\n</code></pre> <p>Check that the size limits are valid.</p>"},{"location":"components/octree/#qseek.octree.Octree.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear the octree's cached data.</p>"},{"location":"components/octree/#qseek.octree.Octree.distances_stations","title":"distances_stations","text":"<pre><code>distances_stations(stations: Stations) -&gt; ndarray\n</code></pre> <p>Returns the 3D distances from all nodes to all stations.</p> <p>Parameters:</p> Name Type Description Default <code>stations</code> <code>Stations</code> <p>Stations to calculate distance to.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Of shape (n-nodes, n-stations).</p>"},{"location":"components/octree/#qseek.octree.Octree.distances_stations_surface","title":"distances_stations_surface","text":"<pre><code>distances_stations_surface(stations: Stations) -&gt; ndarray\n</code></pre> <p>Returns the surface distance from all nodes to all stations.</p> <p>Parameters:</p> Name Type Description Default <code>stations</code> <code>Stations</code> <p>Stations to calculate distance to.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Distances in shape (n-nodes, n-stations).</p>"},{"location":"components/octree/#qseek.octree.Octree.extent","title":"extent","text":"<pre><code>extent() -&gt; tuple[float, float, float]\n</code></pre> <p>Returns the extent of the octree.</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: EW, NS and depth extent of the octree in meters.</p>"},{"location":"components/octree/#qseek.octree.Octree.get_corners","title":"get_corners","text":"<pre><code>get_corners() -&gt; list[Location]\n</code></pre> <p>Get the corners of the octree.</p> <p>Returns:</p> Type Description <code>list[Location]</code> <p>list[Location]: List of locations.</p>"},{"location":"components/octree/#qseek.octree.Octree.get_nodes","title":"get_nodes","text":"<pre><code>get_nodes(indices: Iterable[int]) -&gt; list[Node]\n</code></pre> <p>Retrieves a list of nodes from the octree based on the given indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>Iterable[int]</code> <p>The indices of the nodes to retrieve.</p> required <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: A list of nodes corresponding to the given indices.</p>"},{"location":"components/octree/#qseek.octree.Octree.get_nodes_by_threshold","title":"get_nodes_by_threshold","text":"<pre><code>get_nodes_by_threshold(semblance_threshold: float = 0.0) -&gt; list[Node]\n</code></pre> <p>Get all nodes with a semblance above a threshold.</p> <p>Parameters:</p> Name Type Description Default <code>semblance_threshold</code> <code>float</code> <p>Semblance threshold. Default is 0.0.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: List of nodes.</p>"},{"location":"components/octree/#qseek.octree.Octree.get_nodes_level","title":"get_nodes_level","text":"<pre><code>get_nodes_level(level: int = 0) -&gt; list[Node]\n</code></pre> <p>Get all nodes at a specific level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Level to get nodes from.</p> <code>0</code> <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: List of nodes.</p>"},{"location":"components/octree/#qseek.octree.Octree.interpolate_max_semblance","title":"interpolate_max_semblance  <code>async</code>","text":"<pre><code>interpolate_max_semblance(peak_node: Node) -&gt; Location\n</code></pre> <p>Interpolate the location of the maximum semblance value.</p> <p>This method calculates the location of the maximum semblance value by performing interpolation using surrounding nodes. It uses the scipy Rbf (Radial basis function) interpolation method to fit a smooth function to the given data points. The function is then minimized to find the location of the maximum value.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>Location of the maximum semblance value.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If no semblance values are set.</p>"},{"location":"components/octree/#qseek.octree.Octree.map_semblance","title":"map_semblance","text":"<pre><code>map_semblance(semblance: ndarray, leaf_only: bool = True) -&gt; None\n</code></pre> <p>Maps semblance values to nodes.</p> <p>Parameters:</p> Name Type Description Default <code>semblance</code> <code>ndarray</code> <p>Of shape (n-nodes,).</p> required <code>leaf_only</code> <code>bool</code> <p>If True, only leaf nodes are mapped. Defaults to True.</p> <code>True</code>"},{"location":"components/octree/#qseek.octree.Octree.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Initialize octree. This method is called by the pydantic model.</p>"},{"location":"components/octree/#qseek.octree.Octree.reduce_axis","title":"reduce_axis","text":"<pre><code>reduce_axis(surface: Literal['NE', 'ED', 'ND'] = 'NE', max_level: int = -1, accumulator: Callable[ndarray] = max) -&gt; ndarray\n</code></pre> <p>Reduce the octree's nodes to the surface.</p> <p>Parameters:</p> Name Type Description Default <code>surface</code> <code>Literal['NE', 'ED', 'ND']</code> <p>Surface to reduce to. Defaults to \"NE\".</p> <code>'NE'</code> <code>max_level</code> <code>int</code> <p>Maximum level to reduce to. Defaults to -1.</p> <code>-1</code> <code>accumulator</code> <code>Callable</code> <p>Accumulator function. Defaults to np.max.</p> <code>max</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Of shape (n-nodes, 4) with columns (east, north, depth, value).</p>"},{"location":"components/octree/#qseek.octree.Octree.reset","title":"reset","text":"<pre><code>reset() -&gt; Self\n</code></pre> <p>Reset the octree to its initial state and return it.</p>"},{"location":"components/octree/#qseek.octree.Octree.save_pickle","title":"save_pickle","text":"<pre><code>save_pickle(filename: Path) -&gt; None\n</code></pre> <p>Save the octree to a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>Filename to save to.</p> required"},{"location":"components/octree/#qseek.octree.Octree.set_level","title":"set_level","text":"<pre><code>set_level(level: int) -&gt; None\n</code></pre> <p>Set the octree to a specific level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Level to set the octree to.</p> required"},{"location":"components/octree/#qseek.octree.Octree.smallest_node_size","title":"smallest_node_size","text":"<pre><code>smallest_node_size() -&gt; float\n</code></pre> <p>Returns the smallest possible node size.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Smallest possible node size.</p>"},{"location":"components/octree/#qseek.octree.Octree.total_number_nodes","title":"total_number_nodes","text":"<pre><code>total_number_nodes() -&gt; int\n</code></pre> <p>Returns the total number of nodes of all levels.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total number of nodes.</p>"},{"location":"components/ray_tracer/","title":"Ray Tracers","text":"<p>The calculation of seismic travel times is a cornerstone for the migration and stacking approach. Qseek supports different ray tracers for travel time calculation, which can be adapted for different geological settings.</p>"},{"location":"components/ray_tracer/#constant-velocity","title":"Constant Velocity","text":"<p>The constant velocity models is trivial and follows:</p> \\[ t_{P} = \\frac{d}{v_P} \\] <p>This module is used for simple use cases and cross-referencing testing.</p> <p></p>"},{"location":"components/ray_tracer/#exec-7--constantvelocitytracer-module","title":"ConstantVelocityTracer Module","text":"<p>Travel time tracer with a constant velocity.</p> Config ConstantVelocityTracerJSON  <code>phase</code>: <code>constant:P</code> <p>Name of the phase.</p> <code>velocity</code>: <code>5000.0</code> <p>Constant velocity of the phase in m/s.</p> JSON for ConstantVelocityTracer<pre><code>{\n  \"tracer\": \"ConstantVelocityTracer\",\n  \"phase\": \"constant:P\",\n  \"velocity\": 5000.0\n}\n</code></pre>"},{"location":"components/ray_tracer/#1d-layered-model","title":"1D Layered Model","text":"<p>Calculation of travel times in 1D layered media is based on the Pyrocko Cake ray tracer.</p> <p> Pyrocko Cake 1D ray tracer for travel time calculation in 1D layered media</p> <p></p>"},{"location":"components/ray_tracer/#exec-8--caketracer-module","title":"CakeTracer Module","text":"<p>Travel time ray tracer for 1D layered earth models.</p> Config CakeTracerJSON  <code>phases</code> <p>Dictionary of phases and timings to calculate.</p> <code>earthmodel</code> <p>Earth model to calculate travel times for.</p> <code>trim_earth_model_depth</code>: <code>True</code> <p>Trim earth model to max depth of the octree.</p> <code>lut_cache_size</code> <p>Size of the LUT cache. Default is <code>2G</code>.</p> JSON for CakeTracer<pre><code>{\n  \"tracer\": \"CakeTracer\",\n  \"phases\": {\n    \"cake:P\": {\n      \"definition\": \"P,p\"\n    },\n    \"cake:S\": {\n      \"definition\": \"S,s\"\n    }\n  },\n  \"earthmodel\": {\n    \"filename\": \"/home/runner/.cache/qseek/velocity_models/default.nd\",\n    \"format\": \"nd\",\n    \"crust2_profile\": \"\"\n  },\n  \"trim_earth_model_depth\": true,\n  \"lut_cache_size\": 2147483648\n}\n</code></pre>"},{"location":"components/ray_tracer/#3d-fast-marching","title":"3D Fast Marching","text":"<p>We implement the fast marching method for calculating first arrivals of waves in 3D volumes. Currently three different 3D velocity models are supported:</p> <ul> <li> Import NonLinLoc 3D velocity model</li> <li> 1D layered model \ud83e\udd5e</li> <li> Constant velocity, mainly for testing purposes \ud83e\udd7c</li> </ul> <p> Conceptual 2D visualisation for seismic traveltimes calculation in heterogenous media using the fast-marching method for the Eikonal solution is presented. Traveltimes from the receiving station at the surface (indicated by a yellow triangle) towards the subsurface grid are calculated, resulting in station-specifig traveltimes for all potential source locations simultaneously.</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/markdown_exec/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/markdown_exec/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n7&gt;\", line 2, in &lt;module&gt;\n    from qseek.insights.tracers.fast_marching import FastMarchingTracer\nModuleNotFoundError: No module named 'qseek.insights'\n</code></pre>"},{"location":"components/ray_tracer/#visualizing-3d-models","title":"Visualizing 3D Models","text":"<p>For quality check, all 3D velocity models are exported to <code>vtk/</code> folder as <code>.vti</code> files. Use ParaView to inspect and explore the velocity models.</p> <p> Seismic velocity model of the Utah FORGE testbed site, visualized in ParaView.</p>"},{"location":"components/station_corrections/","title":"Station Corrections","text":"<p>Station corrections can be extract from previous runs to refine the localisation accuracy. The corrections can also help to improve the semblance find more events in a dataset.</p>"},{"location":"components/station_corrections/#station-specific-corrections","title":"Station Specific Corrections","text":"<p> Statistics of station delay times.</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/markdown_exec/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/markdown_exec/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n8&gt;\", line 2, in &lt;module&gt;\n    from qseek.insights import StationCorrections\nModuleNotFoundError: No module named 'qseek.insights'\n</code></pre>"},{"location":"components/station_corrections/#source-specific-corrections","title":"Source Specific Corrections","text":"<p> Delay volume for a selected stations.</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/markdown_exec/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/markdown_exec/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n9&gt;\", line 2, in &lt;module&gt;\n    from qseek.insights import SourceSpecificStationCorrections\nModuleNotFoundError: No module named 'qseek.insights'\n</code></pre>"},{"location":"components/station_metadata/","title":"Station Metadata","text":""},{"location":"components/station_metadata/#station-metadata","title":"Station Metadata","text":"<p>Meta data is required primarily for station locations and codes.</p> <p>Supported data formats are:</p> <ul> <li> StationXML</li> <li> Pyrocko Station YAML</li> </ul> <p>Metadata does not need to include response information for pure detection and localisation. If local magnitudes M<sub>L</sub> are extracted, response information is required.</p> <p></p>"},{"location":"components/station_metadata/#exec-12--stations-module","title":"Stations Module","text":"Config StationsJSON  <code>pyrocko_station_yamls</code> <p>List of Pyrocko station YAML files.</p> <code>station_xmls</code> <p>List of StationXML files or directories containing StationXML (.xml) files.</p> <code>blacklist</code> <p>Blacklist stations and exclude from detecion. Format is <code>['NET.STA.LOC', ...]</code>.</p> <code>max_distance</code> <p>Maximum distance in meters from the centroid location to include stations for detection. If None, all stations are included.</p> JSON for Stations<pre><code>{\n  \"pyrocko_station_yamls\": [],\n  \"station_xmls\": [],\n  \"blacklist\": [],\n  \"stations\": [],\n  \"max_distance\": null\n}\n</code></pre>"},{"location":"components/waveform_data/","title":"Waveform Data","text":"<p>The seismic can be delivered in MiniSeed or any other format compatible with Pyrocko. Qseek utilizes the Pyrocko Squirrel for fast and asynchronous data access.</p> <p>To prepare your data for EQ detection and localisation, organize it in a MiniSeed file or an SDS structure.</p> <p></p>"},{"location":"components/waveform_data/#exec-13--pyrockosquirrel-module","title":"PyrockoSquirrel Module","text":"<p>Waveform provider using Pyrocko's Squirrel.</p> Config PyrockoSquirrelJSON  <code>environment</code> <p>Path to a Pyrocko Squirrel environment.</p> <code>persistent</code> <p>Name of the Squirrel's persistent collection for faster loading of large data sets.</p> <code>waveform_dirs</code> <p>List of directories holding the waveform files.</p> <code>start_time</code> <p>Start time for the search in ISO8601 including timezone. E.g. <code>2024-12-30T00:00:00Z</code>.</p> <code>end_time</code> <p>End time for the search in ISO8601 including timezone. E.g. <code>2024-12-31T00:00:00Z</code>.</p> <code>channel_selector</code> <p>Channel selector for waveforms, e.g. <code>['HH', 'EN']</code>.</p> <code>n_threads</code>: <code>8</code> <p>Number of threads for loading waveforms, important for large data sets.</p> <code>watch_waveforms</code> <p>Watch the waveform directories for changes. If <code>True</code> it will check every ten minutes. If a <code>timedelta</code> is provided it will check every specified time. Default is False.</p> JSON for PyrockoSquirrel<pre><code>{\n  \"provider\": \"PyrockoSquirrel\",\n  \"environment\": null,\n  \"persistent\": \"docs\",\n  \"waveform_dirs\": [\n    \"./data\"\n  ],\n  \"start_time\": null,\n  \"end_time\": null,\n  \"channel_selector\": null,\n  \"n_threads\": 8,\n  \"watch_waveforms\": false\n}\n</code></pre>"}]}